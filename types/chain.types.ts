import { BlockType } from './block.types';
import { GraphID } from './graph.types';
import { PinaxID } from './pinax.types';
import {
  ___InternalConsensusLayerServices,
  ___InternalSupportedServices,
  ConsensusLayerServices,
  SupportedServices,
} from './service.types';
import { Standard } from './standard.types';

export type ChainBase = {
  // Testnet ID
  id: PinaxID;

  // Testnet Name
  name: string;

  // Alternative Names
  alt_names: string[];

  // The Graph ID
  // See docs/retrieve_graph_ids.md
  graph_id: GraphID | null;

  // Display Priority, lower is higher
  index?: number;

  // Chain Standard (ie. ERC20)
  // One good reference to determine chain standard is
  // https://thegraph.com/docs/en/developing/supported-networks/
  standard: Standard | null;

  // Whether or not the chain supports detailed blocks.
  // Not all chains are equal, some uses RPC poller
  // which only offer partial blocks.
  // See whether or not RPC poller is ticked on the
  // Blockchain Service Matrix (https://www.notion.so/pinaxnetwork/Blockchain-Service-Matrix).
  is_detailed_blocks: boolean;

  // Block Type
  block_type: BlockType;
};

export type ___InternalTestnet = ChainBase & {
  // Whether or not the chain supports our existing services
  supported_services: ___InternalSupportedServices;

  metadata?: {
    // Chain ID that replaces this (deprecated) chain
    deprecated_replacing_chain?: PinaxID;
  };
};

export type ___InternalConsensusLayer = ChainBase & {
  // Whether or not the chain supports our existing services
  // Consensus Layers exist only for services built on top of RPC
  // (Firehose, Substreams), and not for the RPC service itself.
  supported_services: ___InternalConsensusLayerServices;
};

export type ___InternalEVM = ChainBase & {
  // Whether or not the chain supports our existing services
  supported_services: ___InternalSupportedServices;
};

/**
 * Describes the Data that needs to be provided for a Chain.
 *
 * The Chain type theb extends the Chain type to include
 * the generated fields.
 */
export interface ___InternalChain extends ChainBase {
  icon: {
    // Token Icon ID
    // See if icon is available on https://tokenicons.io/, if not create PR to add it.
    // Then go on the Github Repo and find the icon ID under /packages/core/src/metadata/
    // https://github.com/0xa3k5/token-icons
    id: string;

    // Theme of the Icon brand
    // To avoid placing a dark icon on a dark background.
    // If the brand is in midtones or some vibrant color, use 'both'.
    brand_theme: 'light' | 'dark' | 'both';

    // Generated by ./scripts/generate/data_json.js
    variants?: Array<'branded' | 'mono'>;
  };

  // Whether or not the chain supports our existing services
  supported_services: ___InternalSupportedServices;

  // Merged by ./scripts/generate/data_json.js
  testnets?: Array<___InternalTestnet>;

  // Merged by ./scripts/generate/data_json.js
  consensus?: Array<___InternalConsensusLayer>;

  // Merge by ./scripts/generate/data_json.js
  evms?: Array<___InternalEVM>;

  // Any additional metadata we want to store (ie. Wagmi)
  metadata?: {
    // Layer of the chain
    layer?: 'L0' | 'L1' | 'L2' | 'L3';

    // Website of the chain
    website?: string;

    // Mainchain ID, if the chain is a sidechain
    // Either a PinaxID or a string, as the mainchain may not be in the list of chains
    mainchain_id?: PinaxID | string;

    // tags for the chain
    tags?: string[];

    // Chain ID that replaces this (deprecated) chain
    deprecated_replacing_chain?: PinaxID;
  };
}

export type Testnet = ChainBase & {
  // Whether or not the chain supports our existing services
  supported_services: SupportedServices;

  metadata?: {
    // Chain ID that replaces this (deprecated) chain
    deprecated_replacing_chain?: PinaxID;
  };
};

export type ConsensusLayer = ChainBase & {
  // Whether or not the chain supports our existing services
  // Consensus Layers exist only for services built on top of RPC
  // (Firehose, Substreams), and not for the RPC service itself.
  supported_services: ConsensusLayerServices;
};

export type EVM = ChainBase & {
  // Whether or not the chain supports our existing services
  supported_services: SupportedServices;
};

/**
 * Describes the Data that needs to be provided for a Chain.
 *
 * The Chain type theb extends the Chain type to include
 * the generated fields.
 */
export interface Chain extends ChainBase {
  icon: {
    // Token Icon ID
    id: string;

    // Theme of the Icon brand
    brand_theme: 'light' | 'dark' | 'both';

    // Generated by ./scripts/generate/data_json.js
    variants?: Array<'branded' | 'mono'>;
  };

  // Whether or not the chain supports our existing services
  supported_services: SupportedServices;

  // Merged by ./scripts/generate/data_json.js
  testnets?: Array<Testnet>;

  // Merged by ./scripts/generate/data_json.js
  consensus?: Array<ConsensusLayer>;

  // Merge by ./scripts/generate/data_json.js
  evms?: Array<EVM>;

  // Any additional metadata we want to store (ie. Wagmi)
  metadata?: {
    // Layer of the chain
    layer?: 'L0' | 'L1' | 'L2' | 'L3';

    // Website of the chain
    website?: string;

    // Mainchain ID, if the chain is a sidechain
    // Either a PinaxID or a string, as the mainchain may not be in the list of chains
    mainchain_id?: PinaxID | string;

    // tags for the chain
    tags?: string[];

    // Chain ID that replaces this (deprecated) chain
    deprecated_replacing_chain?: PinaxID;
  };
}
